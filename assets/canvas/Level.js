
//-- user code here --

/* --- start generated code --- */

// Generated by  1.5.3 (Phaser v2.6.2)


/**
 * Level.
 */
function Level() {
	
	Phaser.State.call(this);
	
}

/** @type Phaser.State */
var Level_proto = Object.create(Phaser.State.prototype);
Level.prototype = Level_proto;
Level.prototype.constructor = Level;

Level.prototype.init = function () {
	
	this.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;
	this.scale.pageAlignHorizontally = true;
	this.scale.pageAlignVertically = true;
	this.stage.backgroundColor = '#ffffff';
	
};

Level.prototype.preload = function () {
	
	this.load.pack('Level', 'assets/pack.json');
	
};

Level.prototype.create = function () {
	this.add.text(343.9580078125, 292.2246398925781, 'Hello world!', {"font":"bold 20px Arial"});
	
	var _mountains = new mtn_prefab(this.game, -1603.0, -94.0);
	this.add.existing(_mountains);
	
	var _cat = this.add.sprite(187.0, 226.0, 'cat', 0);
	_cat.animations.add('stand', [0, 1, 2], 0, false);
	
	
	
	// fields
	
	this.fMountains = _mountains;
	this.fCat = _cat;
	
	this.SecondCreate();
	createRoad();
	
};

/* --- end generated code --- */
//-- user code here --

// Step-by-step how to make a racing game!
// found here:
// https://codeincomplete.com/posts/javascript-racer-v1-straight/

var secondCreate  = 0; // to trigger our own Crate() function
var distance      = 0; // the distance the car has traveled
var speed         = 0;
var roadSegments  = []; // array of the road segments using p1 and p2
var segmentLength = 200;
var width         = 500;                    // logical canvas width
var height        = 350;                     // logical canvas height
var background    = null;                    // our background image (loaded below)
var sprites       = null;                    // our spritesheet (loaded below)
var roadWidth     = 500;                    // actually half the roads width, easier math if the road spans from -roadWidth to +roadWidth
var rumbleLength  = 7;                       // number of segments per red/white rumble strip
var trackLength   = null;                    // z length of entire track (computed)
var lanes         = 2;                       // number of lanes
var fieldOfView   = 50;                     // angle (degrees) for field of view
var cameraHeight  = 300;                    // z height of camera
var drawDistance  = 200;                     // number of segments to draw
var playerX       = 0;                       // player x offset from center of road (-1 to 1 to stay independent of roadWidth)
var cameraDepth   = 1 / Math.tan((fieldOfView/2) * Math.PI/180); // // z distance camera is from screen (computed)
var playerZ       = (cameraHeight * cameraDepth);                    // player relative z distance from camera (computed)
var sprite;
var jumpOffset 	  = 0; 
var isJumping     = 0;
var originalY;
var isInTouch     = false;
var touch         = true;
var mtn_speed     = .3;
var mtn_offset    = 0;
var orig_x        = 0;

var COLORS = {
		LIGHT:  { road: '0xaaaaaa', grass: '0x4d9fdd', rumble: '0x555555', lane: '0x641E16'  },
		DARK:   { road: '0xbbbbbb', grass: '0x1483c7', rumble: '0x641E16'                    }
};

Level.prototype.SecondCreate = function() {	
	//this.fCat = this.game.add.sprite(this.fCat.x, this.fCat.y - 50, 'cat');
	this.fCat.scale.setTo(1.5);
	originalY = this.fCat.y;
	this.game.time.advancedTiming = true; // so we can display fps
	this.cursors = this.input.keyboard.createCursorKeys(); // add keyboard keys - later replace with with where you are touching the screen
	this.game.stage.backgroundColor = "#adbce6"; // make the background a nice sky blue
	graphics = this.game.add.graphics(0, 0); // add some graphics so we can draw POLYGONS
	distance = 0; // distance the player has traveled
	this.spaceKey = this.game.input.keyboard.addKey(Phaser.Keyboard.SPACEBAR);
	this.game.input.keyboard.addKeyCapture([Phaser.Keyboard.SPACEBAR ]);
	this.game.input.onTap.add(onTap, this);

	this.game.input.onDown.add(startInput, this);
	this.game.input.onUp.add(endInput, this);

	//this._mountains = this.game.add.sprite(250, 200, 'mtn');
	this.fMountains.x = 250;
	this.fMountains.y = 200;
	this.fMountains.scale.setTo(0.3);
	this.fMountains.sendToBack();
	this.fMountains.anchor.setTo(0.5);
	orig_x = this.fMountains.x;
};

// keeps track of if we are touching the screen
function startInput(){
	isInTouch = true;
}

function endInput(){
	isInTouch = false;
}

function onTap(pointer, doubleTap) {
	if(!isJumping){
		isJumping = 1;
        this.startJump();
	}
}

Level.prototype.update = function() {
	// we need to make sure the distance is always less than the track length
	var distance_unclamped = distance + Math.min(Math.max(this.time.physicsElapsed * speed * 50, 0), trackLength);
	if ( distance_unclamped > trackLength){ // If we have finished the whole track,
		distance_unclamped = 0;             // fake looping by teleporting us back to start
	}
	distance = Math.min(Math.max(distance_unclamped, -1), trackLength);
	
	// SPEED CALCULATIONS
	var speedPercent = speed/200;
	var dx = this.time.physicsElapsed * speedPercent;
	speed += (this.cursors.up.isDown || (isInTouch && this.game.input.y < 250)) ? this.time.physicsElapsed * 70 : -1;
	speed = Math.min(Math.max(speed, 0), 200); //clamp speed

	// INPUT 
	if (this.spaceKey.isDown && !isJumping)
    {
    	isJumping = 1;
        this.startJump();
    }
	if (( this.cursors.left.isDown  && !this.cursors.right.isDown && !touch) || (touch && this.game.input.x <  200 && isInTouch)) { playerX -= dx; this.fCat.frame = 2;}
	if ((!this.cursors.left.isDown  &&  this.cursors.right.isDown && !touch) || (touch && this.game.input.x >= 300 && isInTouch)) { playerX += dx; this.fCat.frame = 1; }
	if ((!this.cursors.right.isDown && !this.cursors.left.isDown  && !touch) || (touch && (!isInTouch || (200 < this.game.input.x) &&(this.game.input.x  < 300))) ){ this.fCat.frame = 0; }

	// RENDER GEOMETRY
	graphics.clear(); // delete polygons from last frame
	renderRoad(); // draw new polygons
	// we want to move the car L/R based on the road it's on to help the player turn
	var playerSegment = roadSegments[Math.floor((distance+playerZ)/segmentLength) % roadSegments.length];

	// Offset mountain's x position to give illusion of turning
	mtn_offset = mtn_offset - (dx * speedPercent * playerSegment.curvature * mtn_speed * speed);

	// move the car left/right
	playerX = playerX - (dx * speedPercent * playerSegment.curvature * 1.1);
	this.fMountains.x = orig_x + mtn_offset;
	this.fCat.bringToTop(); // bring the car to the top
};

Level.prototype.startJump = function(){
	tween = this.game.add.tween(this.fCat).to( { y: '-50' }, 250, Phaser.Easing.Quadratic.Out, true);
    tween.onComplete.addOnce(endJump, this);
};

function endJump(){
	tween = this.game.add.tween(this.fCat).to( { y: '+50' }, 250, Phaser.Easing.Quadratic.In, true);
	tween.onComplete.addOnce(resetJump, this);
}

function resetJump(){
	isJumping = 0;
}

// a function that will let us tween the curvature of each segment as we add curved track sections
function tweenCurve(init,target,percent,type){
	var tweenVal = 0;
	switch(type){
		case "EaseIn":
			tweenVal = init + (target-init) * Math.pow(percent,2);
			break;
		case "EaseOut":
			tweenVal = init + (target-init) * (1 - Math.pow(1 - percent,2));
			break;
		case "EaseInOut":
			tweenVal = init + (target-init) * ((-Math.cos(percent * Math.PI)/2) + 0.5);
			break;
	}
	return tweenVal;
}

// here, we will create the whole track
function createRoad(){ // make the road!
	create_curve(50,50,50,0,15);
	create_curve(100,100,75,1,-5);
	create_curve(30,30,30,0,-3);
	create_curve(30,30,30,0,7);
	create_curve(100,100,100,-0.7,-9);
	create_curve(100,100,100,0.3,4);
	create_curve(100,100,100,0.7,-5);
	create_curve(100,100,100,-0.3,0);
	create_curve(100,100,100,-0.2,-4);
	trackLength = roadSegments.length * segmentLength; // calculate the track length
}

// gives you the last Y - this is needed to add hills
function lastY(){ 
	return (roadSegments.length == 0? 0 : roadSegments[roadSegments.length - 1].p2.world.y);
}

// pushes one road segment into the roadSegment array
function add_roadSection (curve, y_){
	var i =  roadSegments.length + 1;
	// add: index, bottom line of segment (closest to camera) , top line (which is the next segments bottom line)
	// and the color
	roadSegments.push({
		index:i,
		p1:{ world:{y: lastY(), z: i * segmentLength}, camera: {}, screen: {}},
		p2:{ world:{y: y_, z: (i + 1) * segmentLength}, camera: {}, screen: {}},
		color: Math.floor(i/rumbleLength)%2 ? COLORS.DARK : COLORS.LIGHT,
		curvature: curve
	});		
}

// from the website - not totally sure why this gives you the end Y
function toInt(obj, def) {
	if (obj !== null){
		var x = parseInt(obj, 10);
		if (!isNaN(x)){
			return x; 
		}
	}
	return toInt(def, 0);
}

// makes smooth transition to/from a curved piece of track
function create_curve(enter,hold,leave, curvature,y){
	var n, total = enter + hold + leave;
	var startY = lastY();
	var endY = startY + (toInt(y,0) * segmentLength);
	for(n = 0; n < enter; n ++){
		add_roadSection(tweenCurve(0,curvature,n/enter,"EaseIn"),tweenCurve(startY,endY,n/total,"EaseInOut"));
	}	
	for(n = 0; n < hold; n ++){
		add_roadSection(curvature,tweenCurve(startY,endY,(enter+n)/total,"EaseInOut"));
	}
	for(n = 0; n < leave; n ++){
		add_roadSection(tweenCurve(curvature,0,n/leave,"EaseInOut"),tweenCurve(startY,endY,(enter+hold+n)/total,"EaseInOut"));
	}
}

// draw a nice polygon
function renderPolygon(x1, y1, x2, y2, x3, y3, x4, y4, color) { 
	var poly = new Phaser.Polygon([ 
               new Phaser.Point(x1, y1), 
               new Phaser.Point(x2, y2), 
               new Phaser.Point(x3, y3), 
               new Phaser.Point(x4, y4)
               ]);
	graphics.beginFill(color); 
	graphics.drawPolygon(poly.points); // make it official
	graphics.endFill();
}

// math from the article  - to decide the polygon's shape
function segment_maker(x1, y1, w1, x2, y2, w2, color) {
	var r1 = w1/Math.max(9,  2*lanes),
	r2 = w2/Math.max(9,  2*lanes),
	l1 = w1/Math.max(32, 8*lanes),
	l2 = w2/Math.max(32, 8*lanes),
	lanew1, lanew2, lanex1, lanex2, lane;

	graphics.beginFill(color.grass);
	grass_poly = graphics.drawRect(0, y2, width, y1-y2);
	// call the function that draws the polygons
	renderPolygon(x1-w1-r1, y1, x1-w1, y1, x2-w2, y2, x2-w2-r2, y2, color.rumble);
	renderPolygon(x1+w1+r1, y1, x1+w1, y1, x2+w2, y2, x2+w2+r2, y2, color.rumble);
	renderPolygon(x1-w1,    y1, x1+w1, y1, x2+w2, y2, x2-w2,    y2, color.road  );

	if (color.lane) { // draws lanes - math from website
		lanew1 = w1*2/lanes;
		lanew2 = w2*2/lanes;
		lanex1 = x1 - w1 + lanew1;
		lanex2 = x2 - w2 + lanew2;

		for(lane = 1 ; lane < lanes ; lanex1 += lanew1, lanex2 += lanew2, lane++){
			renderPolygon(lanex1 - l1/2, y1, lanex1 + l1/2, y1, lanex2 + l2/2, y2, lanex2 - l2/2, y2, color.lane);
		}
	}
}

// rendering logic - looks at the segments info and draws it
function renderRoad(){
	// find the segment at the bottom, position is like distance
	var baseSegment = roadSegments[Math.floor(distance/segmentLength) % roadSegments.length];
	var maxy = height; // max y (for screen?) is the height of the screen
	var current_segment; // segment which will be the current segment we are drawing
	var x = 0; // the camera x projection offset
	var playerSegment = roadSegments[Math.floor(distance/segmentLength) % roadSegments.length]; 
	var playerY = playerSegment.p1.world.y + (playerSegment.p2.world.y-playerSegment.p1.world.y);
	var dx = - (baseSegment.curvature * ((distance%segmentLength)/segmentLength)); // increases by the amount of curve - goes up as you approach the horizon

	for(var n = 0; n < drawDistance; n++) { // from 0 to the number of segments we want to draw
		// set segment to be the base segment index + n, % segments length so it loops back to the start if its too short
		current_segment = roadSegments[Math.floor((baseSegment.index + n) % roadSegments.length)];
		current_segment.looped = current_segment.index < baseSegment.index;
		var dist_offset = current_segment.looped ? trackLength : 0;
		// project p1 and p2
		project(current_segment.p1, (playerX * roadWidth) - x, cameraHeight + playerY, distance - dist_offset);
		project(current_segment.p2, (playerX * roadWidth) - x - dx, cameraHeight + playerY, distance - dist_offset);

		// x and dx are the offsets to the x positions of the segments
		x += dx;
		dx += current_segment.curvature;

		// if the segment is NOT behind us or not already rendered, draw it
		if ((current_segment.p1.camera.z > cameraDepth) &&
			(current_segment.p2.screen.y < maxy)){
			segment_maker(current_segment.p1.screen.x,
					current_segment.p1.screen.y,
					current_segment.p1.screen.w,
					current_segment.p2.screen.x,
					current_segment.p2.screen.y,
					current_segment.p2.screen.w,
					current_segment.color);	
			maxy = current_segment.p2.screen.y; //update the maximum y so we move to the next segment
		}
	}
}

// function from website, projects the points form the world to the screen
function project(p, cameraX, cameraY, cameraZ) {
	// world coordinates -> camera coordinates
	p.camera.x     = (p.world.x || 0) - cameraX;
	p.camera.y     = (p.world.y || 0) - cameraY;
	p.camera.z     = (p.world.z || 0) - cameraZ;
	p.screen.scale = cameraDepth/p.camera.z;
	// camera coordinates -> screeen coordinates
	p.screen.x     = Math.round((width/2)  + (p.screen.scale * p.camera.x  * width/2));
	p.screen.y     = Math.round((width/2) - (p.screen.scale * p.camera.y  * height/2));
	p.screen.w     = Math.round(             (p.screen.scale * roadWidth   * width/2));
}

Level.prototype.render = function() { //  FPS debug info
	this.game.debug.text('FPS: ' + this.game.time.fps || 'FPS: --', 40, 40, "#00ff00");
};
